<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl2 - transformfeedback</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #cccccc;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #050505;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #0080ff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webgl2 - transformfeedback</div>

		<script src="../build/three.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script id="transformVertex" type="x-shader/x-vertex">
			#version 300 es

			in vec3 position;
			in vec3 velocity;
			in vec3 color;

			out vec3 outPosition;
			out vec3 outVelocity;
			out vec3 outColor;

			uniform float deltaTime;
			uniform float time;
			
			#define K_VEL_DECAY 0.99

			vec3 colA = vec3(1.0,1.0,1.0);
			vec3 colB = vec3(1.0,0.0,0.0);

			void main() {

				float uKForce = 150.0;

				// compute force
				//vec3 gravityCenter = vec3(cos(time), sin(time), 0.0) * 10.25;
				vec3 toCenter = - position;
				float toCenterLength = length(toCenter);
				vec3 accel = (toCenter/toCenterLength) * uKForce / toCenterLength;

				outPosition = position + velocity * deltaTime;
				outVelocity = velocity * K_VEL_DECAY + accel * deltaTime;
				
				float l = length(position.xyz) * 0.01;
				vec3 color = mix(colB, colA, l);
				outColor = color;

			}

		</script>

		<script id="fragmentNop" type="x-shader/x-fragment">
			#version 300 es
			precision highp float;

			out vec4 fragColor;

			void main() {

				fragColor = vec4( 1.0, 1.0, 1.0, 1.0 );

			}
		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, renderer, clock;

			var mesh, transformFeedback;
			var NUM_PARTICLES = 10000;

			THREE.TransformFeedback = function ( material, mesh ) {

				this.material = material;
				this.mesh = mesh;

				this.source = this.mesh.geometry;
				this.target = this.source.clone();

				}

				THREE.TransformFeedback.prototype = {

				tick: function () {

					renderer.processTransformFeedback( this.source, this.target, this.material );
					
					this.mesh.geometry = this.target;

					// Ping pong buffers
					this.target = this.source;
					this.source = this.mesh.geometry;

				}

			};

			init();
			animate();

			function init() {

				clock = new THREE.Clock();

				container = document.getElementById( 'container' );

				//

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3500 );
				camera.position.y = 30;
				camera.position.z = 50;

				controls = new THREE.OrbitControls( camera );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x050505 );
				scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );

				//

				scene.add( new THREE.AmbientLight( 0x444444 ) );

				//

				var canvas = document.createElement( 'canvas' );
				var context = canvas.getContext( 'webgl2' );

				renderer = new THREE.WebGLRenderer( { canvas: canvas, context: context } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				container.appendChild( renderer.domElement );

				initParticles();
				initTransformFeedback();

				//

				stats = new Stats();
				container.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}


			function initParticles() {

				var geometry = new THREE.BufferGeometry();

				var positions = [];

				for ( var i = 0; i < NUM_PARTICLES; i ++ ) {

					// positions
					var r = Math.random() * 100.0 + 2.0;
					var angle = Math.random() * Math.PI * 2;
					var angle2 = Math.random() * Math.PI * 2;
					positions.push( r * Math.sin( angle ) * Math.cos( angle2 ),
						r * Math.sin( angle ) * Math.sin( angle2 ),
						r * Math.cos( angle ) 
					);
				}

				geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3, false ) );
				geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( new Float32Array( NUM_PARTICLES * 3 ), 3 ) );
				geometry.addAttribute( 'velocity', new THREE.Float32BufferAttribute( new Float32Array( NUM_PARTICLES * 3 ), 3, false ) );

				points = new THREE.Points( geometry, new THREE.PointsMaterial( {
					size: 0.5,
					vertexColors: THREE.VertexColors
				} ) );

				scene.add( points );

			}

			function initTransformFeedback() {

				var material = new THREE.RawShaderMaterial( {
					uniforms: {
						deltaTime: { value: 0.0 },
						time: { value: 0.0 }
					},
					vertexShader: document.getElementById( 'transformVertex' ).textContent.trim(),
					fragmentShader: document.getElementById( 'fragmentNop' ).textContent.trim(),
					transformFeedbackVaryings: {
						outPosition: 'position',
						outVelocity: 'velocity',
						outColor: 'color'
					}
				} );

				transformFeedback = new THREE.TransformFeedback( material, points );
			}

			//

			function animate() {

				requestAnimationFrame( animate );

				// Transform feedback update
				transformFeedback.material.uniforms.deltaTime.value = clock.getDelta();
				transformFeedback.material.uniforms.time.value += transformFeedback.material.uniforms.deltaTime.value
				transformFeedback.tick();


				renderer.render( scene, camera );
				stats.update();

			}

		</script>

	</body>
</html>
