<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - postprocessing - progressive surface accumulation</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="container"></div>
		<div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			<br/>Progressive Surface Accumulator Demo by <a href="https://github.com/zalo" target="_blank" rel="noopener">zalo</a><br/>
			[Inspired by <a href="http://madebyevan.com/shaders/lightmap/" target="_blank" rel="noopener">evanw's Lightmap Generation</a>]
		</div>

		<script type="module">
			import * as THREE from '../build/three.module.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';
			import { OBJLoader } from './jsm/loaders/OBJLoader.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { TransformControls } from './jsm/controls/TransformControls.js';
			import { ProgressiveSurfacemap } from './jsm/misc/ProgressiveSurfacemap.js';

			// ShadowMap Res and Number of Directional Lights
			let shadowMapRes = 512, lightCount = 8;

			let camera, scene, renderer, dirLights = [], controls, control, control2, 
				object = new THREE.Mesh(), lightOrigin = null, progressiveSurfacemap;
			const params = { Enable: true, BlendWindow: 200, LightRadius: 50, AmbientWeight: 0.5, BlurEdges: true };

			init();
			createGUI();
			animate();

			function init() {

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
				camera.position.set(0, 100, 200);
				camera.name = "Camera";

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x949494);
				scene.fog = new THREE.Fog(0x949494, 1000, 3000);

				// Progressive Lightmap
				progressiveSurfacemap = new ProgressiveSurfacemap(scene, renderer, 512);

				// Transform Gizmo
				lightOrigin = new THREE.Group();
				lightOrigin.position.set(60, 150, 100);
				scene.add(lightOrigin);
				control = new TransformControls( camera, renderer.domElement );
				control.addEventListener( 'dragging-changed', ( event ) => { controls.enabled = ! event.value; } );
				control.attach( lightOrigin );
				scene.add( control );
				progressiveSurfacemap.exclude(control); // Exclude the control gizmos from being rendered to the map

				for (let l = 0; l < lightCount; l++){
					let dirLight = new THREE.DirectionalLight(0xffffff, 1.0/lightCount);
					dirLight.name = 'Dir. Light '+l;
					dirLight.position.set(200, 200, 200);
					dirLight.castShadow = true;
					dirLight.shadow.camera.near    =   100;
					dirLight.shadow.camera.far     =   5000;
					dirLight.shadow.camera.right   =   150;
					dirLight.shadow.camera.left    = - 150;
					dirLight.shadow.camera.top	   =   150;
					dirLight.shadow.camera.bottom  = - 150;
					dirLight.shadow.mapSize.width  =   shadowMapRes;
					dirLight.shadow.mapSize.height =   shadowMapRes;
					dirLight.shadow.autoUpdate     =   false; // This technique needs autoupdates disabled!

					scene.add(dirLight);
					dirLights.push(dirLight);
				}

				// ground
				let groundMesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(600, 600),
												new THREE.MeshPhongMaterial({ color: 0xffffff, depthWrite: true}));
				groundMesh.position.y = -0.1;
				groundMesh.rotation.x = - Math.PI / 2;
				groundMesh.name = "GroundMesh";
				scene.add(groundMesh);
				// This adds the model to the surfacemap
				// And replaces its material with a Basic SurfaceMap Material
				progressiveSurfacemap.add(groundMesh);

				// model
				function loadModel() {
					object.traverse( function ( child ) {
						if (child.isMesh) {
							child.name = "Loaded Mesh";
							child.castShadow    = true;
							child.receiveShadow = true;
							// This adds the model to the surfacemap
							// And replaces its material with a Basic SurfaceMap Material
							progressiveSurfacemap.add(child); 
						} else {
							child.layers.disableAll(); // Disable Rendering for this
						}
					} );

					scene.add(object);
					object.scale.set(2, 2, 2);
					object.position.set(0, -16, 0);

					control2 = new TransformControls( camera, renderer.domElement );
					control2.addEventListener( 'dragging-changed', ( event ) => { controls.enabled = ! event.value; } );
					control2.attach( object );
					scene.add( control2 );
					progressiveSurfacemap.exclude(control2); // Exclude the control gizmos from being rendered to the map

					let lightTarget = new THREE.Group();
					lightTarget.position.set(0, 20, 0);
					for (let l = 0; l < dirLights.length; l++) { dirLights[l].target = lightTarget; }
					object.add(lightTarget);
				}

				const manager = new THREE.LoadingManager( loadModel );
				const loader = new OBJLoader( manager );
				loader.load('models/obj/ShadowmappableMesh.obj', function (obj) { object = obj; });
				
				// controls
				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.05;
				controls.screenSpacePanning = true;
				controls.minDistance = 100;
				controls.maxDistance = 500;
				controls.maxPolarAngle = Math.PI / 1.5;
				controls.target.set(0, 100, 0);

				window.addEventListener( 'resize', onWindowResize );
			}

			function createGUI() {
				const gui = new GUI( { name: 'Accumulation Settings' } );
				gui.add( params, 'Enable' );
				gui.add( params, 'BlurEdges');
				gui.add( params, 'BlendWindow'      , 1, 500 ).step( 1 );
				gui.add( params, 'LightRadius'      , 0, 200 ).step( 10 );
				gui.add( params, 'AmbientWeight'    , 0, 1   ).step( 0.1 );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function render() {
				// Update the inertia on the orbit controls
				controls.update();

				// Accumulate Surface Maps
				if (params.Enable) { progressiveSurfacemap.update(camera, params.BlendWindow, params.BlurEdges); }

				// Manually Update the Directional Lights
				for (let l = 0; l < dirLights.length; l++) {
					// Sometimes they will be sampled from the target direction
					// Sometimes they will be uniformly sampled from the upper hemisphere
					if(Math.random() > params.AmbientWeight){
						dirLights[l].position.set(lightOrigin.position.x + (Math.random() * params.LightRadius),
												  lightOrigin.position.y + (Math.random() * params.LightRadius),
												  lightOrigin.position.z + (Math.random() * params.LightRadius));
					} else {
						// Uniform Hemispherical Surface Distribution for Ambient Occlusion
						let lambda = Math.acos(2 * Math.random() - 1) - (3.14159/2.0);
						let phi = 2 * 3.14159 * Math.random();
						dirLights[l].position.set(((Math.cos(lambda) * Math.cos(phi)) * 300) + object.position.x,
										   Math.abs(Math.cos(lambda) * Math.sin(phi)) * 300  + object.position.y + 20,
												   (Math.sin(lambda)                  * 300) + object.position.z    );
					}
					dirLights[l].shadow.needsUpdate = true; // Don't forget to manually update the lights' shadows!
				}

				// Render Scene
				renderer.render( scene, camera );
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}
		</script>
	</body>
</html>
