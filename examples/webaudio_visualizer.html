<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webaudio - 3D visualizer</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		html, body {
			height:           100%;
			width:            100%;
			overflow:         hidden;
			background-color: black;
		}

		#container {
			height:           100%;
			width:            100%;
			background-color: green;
		}
	</style>
</head>
<body>
<div id="overlay">
	<div>
		<button id="startButton">Click to Play</button>
		<p>Audio playback requires user interaction.</p>
	</div>
</div>
<div id="container"></div>
<div id="info">
	<a href="https://threejs.org" target="_blank" rel="noopener noreferrer">three.js</a> webaudio - 3D visualizer<br/>
	music by <a href="http://www.newgrounds.com/audio/listen/376737" target="_blank" rel="noopener">skullbeatz</a>
</div>

<script type="module">

	import * as THREE from '../build/three.module.js';
	import { OrbitControls } from './jsm/controls/OrbitControls.js';
	import { GUI } from './jsm/libs/dat.gui.module.js';
	import Stats from './jsm/libs/stats.module.js';

	function ThreeApplication( container ) {

		if ( !container ) {
			throw new Error( 'Three Application required a container' );
		}

		this.container = container;

		// initRenderer
		{
			this.frameId = null;

			this.renderer = new THREE.WebGLRenderer( { antialias: true } );
			this.renderer.setPixelRatio( window.devicePixelRatio );
			this.renderer.setSize( window.innerWidth, window.innerHeight );

			this.container.appendChild( this.renderer.domElement );
		}

		// initCamera
		{
			this.camera = new THREE.PerspectiveCamera( 70, this.getAspectRatio(), 0.1, 1000 );
			this.camera.position.set( 0, 3, 3 );
		}

		// initControls
		{
			this.controls = new OrbitControls( this.camera, this.renderer.domElement );
		}

		// initScene
		{
			// SCENE
			this.scene = new THREE.Scene();
			this.scene.background = new THREE.Color( 0x000000 );

			// LIGHTS
			this.ambientLight = new THREE.AmbientLight( 0xaaaaaa );
			this.ambientLight.name = 'AmbiantLight';
			this.ambientLight.visible = true;
			this.scene.add( this.ambientLight );

			this.dirLight = new THREE.DirectionalLight( 0xffffff, 0.750 );
			this.dirLight.position.set( - 30, 10, 10 );
			this.scene.add( this.dirLight );
		}

		// initWaveform
		{
			this.useWaveform = true;
			this.fftWaveformLength = 2048;
			const halfFftLength = this.fftWaveformLength / 2;
			this.currentWaveformBufferIndex = 0;
			this.waveformCycles = 1;
			this.waveforms = new THREE.Group();

			for ( let waveIndex = 0; waveIndex < this.waveformCycles; waveIndex ++ ) {

				// Using bufferd line
				const geometry = new THREE.BufferGeometry();
				const material = new THREE.LineBasicMaterial( {
					vertexColors: THREE.VertexColors
				} );
				const positions = [];
				const colors = [];
				const globalOffset = waveIndex * (halfFftLength / 100);

				for ( let x = 0; x < halfFftLength; x ++ ) {

					const globalXPosition = globalOffset + (x / 100);
					positions.push( globalXPosition, 0, 0 );
					colors.push( 1, 1, 1 );

				}

				const bufferPositionAttribute = new THREE.Float32BufferAttribute( positions, 3 );
				bufferPositionAttribute.setUsage( THREE.DynamicDrawUsage );
				geometry.setAttribute( 'position', bufferPositionAttribute );

				const bufferColorAttribute = new THREE.Float32BufferAttribute( colors, 3 );
				bufferColorAttribute.setUsage( THREE.DynamicDrawUsage );
				geometry.setAttribute( 'color', bufferColorAttribute );

				//                            let boundingBoxCenter = new THREE.Vector3()
				this.waveform = new THREE.Line( geometry, material );
				//                            this.waveform = new THREE.Points( geometry, material )
				//                            this.waveform.geometry.computeBoundingBox()
				//                            this.waveform.geometry.boundingBox.getCenter( boundingBoxCenter )
				//                            this.waveform.position.x = -boundingBoxCenter.x
				//                            this.waveform.position.y = 2
				//                            this.waveform.position.z = -3

				this.waveforms.add( this.waveform );

			}

			const boundingBox = new THREE.Box3();
			let boundingBoxCenter = new THREE.Vector3();
			boundingBox.setFromObject( this.waveforms );
			boundingBox.getCenter( boundingBoxCenter );

			this.waveforms.position.x = - boundingBoxCenter.x;
			this.waveforms.position.y = 1;
			this.waveforms.position.z = - 1;

			this.scene.add( this.waveforms );
		}

		// initSoundMap
		{
			this.useSoundMap = true;
			this.soundMapFftLength = 512;
			this.soundMapBufferLength = 512;
			this.currentAudioBufferIndex = 0;

			// Using bufferd line
			const geometry = new THREE.BufferGeometry();
			const material = new THREE.MeshPhongMaterial( {
				vertexColors: THREE.VertexColors
			} );

			const halfFftLength = this.soundMapFftLength / 2;
			const positions = [];
			const colors = [];
			const indexes = [];

			for ( let x = 0; x < this.soundMapBufferLength; x ++ ) {

				for ( let z = 0; z < halfFftLength; z ++ ) {

					positions.push( x / 100, 0, z / 100 );
					colors.push( 1, 1, 1 );

				}

				// avoid extra indexes
				if ( x === this.soundMapBufferLength - 1 ) {
					break;
				}

				const globalIndex = (x * halfFftLength);
				for ( let i = 0; i < halfFftLength - 1; i ++ ) {

					indexes.push( globalIndex + i, globalIndex + i + 1, globalIndex + i + halfFftLength );
					indexes.push( globalIndex + i + 1, globalIndex + i + halfFftLength + 1, globalIndex + i + halfFftLength );

				}

			}

			const bufferPositionAttribute = new THREE.Float32BufferAttribute( positions, 3 );
			bufferPositionAttribute.setUsage( THREE.DynamicDrawUsage );
			geometry.setAttribute( 'position', bufferPositionAttribute );

			const bufferColorAttribute = new THREE.Float32BufferAttribute( colors, 3 );
			bufferColorAttribute.setUsage( THREE.DynamicDrawUsage );
			geometry.setAttribute( 'color', bufferColorAttribute );

			geometry.setIndex( indexes );
			geometry.computeVertexNormals();

			let boundingBoxCenter = new THREE.Vector3();
			this.soundMap = new THREE.Mesh( geometry, material );
			this.soundMap.geometry.computeBoundingBox();
			this.soundMap.geometry.boundingBox.getCenter( boundingBoxCenter );
			this.soundMap.position.x = - boundingBoxCenter.x;
			this.soundMap.position.y = - boundingBoxCenter.y;
			this.soundMap.position.z = - boundingBoxCenter.z;
			this.scene.add( this.soundMap );
		}

		// initAudio
		{
			this.selectedAudioSource = 'File';

			// Require user gesture
			//			this.audioListener = new THREE.AudioListener();
			//			this.audio = new THREE.Audio( this.audioListener );
			//			this.audioAnalyser = new THREE.AudioAnalyser( this.audio, this.soundMapFftLength );
			//			this.waveAnalyser = new THREE.AudioAnalyser( this.audio, this.fftWaveformLength );
		}

		// initEvents
		{
			window.addEventListener( 'resize', this.resize.bind( this ), false );
		}

		// initDatGui
		{
			var GuiInterface = function () {

				// Audio
				this.audioSource = ['File', 'Microphone'];
				this.toggleAudio = true;

				// FFT
				this.fftAvailablesValues = [32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768];

			};

			this.interface = new GuiInterface();

			this.gui = new GUI( {
				width: 320
			} );

			var folderAudio = this.gui.addFolder( 'Audio' );
			folderAudio.add( this, 'selectedAudioSource', this.interface.audioSource ).name( 'Audio Source' ).onChange( this.setAudioSource.bind( this ) );
			folderAudio.add( this.interface, 'toggleAudio' ).name( 'Start/Stop audio' ).onChange( this.toggleAudio.bind( this ) );

			var folderSoundMap = this.gui.addFolder( 'SoundMap' );
			folderSoundMap.add( this, 'useSoundMap' ).name( 'Active Sound Map' );
			folderSoundMap.add( this, 'soundMapFftLength', this.interface.fftAvailablesValues ).name( 'FFT Width' ).onChange( this.updateSoundMap.bind( this ) );
			folderSoundMap.add( this, 'soundMapBufferLength' ).name( 'Buffer Length' ).onChange( this.updateSoundMap.bind( this ) );

			var folderWaveForm = this.gui.addFolder( 'WaveForm' );
			folderWaveForm.add( this, 'useWaveform' ).name( 'Active Waveform' );
		}

		// initStats
		{
			this.showStats = true;
			this.stats = new Stats();
			this.container.appendChild( this.stats.dom );
		}

	}

	Object.assign( ThreeApplication.prototype, {

		constructor: ThreeApplication,

		// Audio
		setAudioSource( source ) {

			this.selectedAudioSource = source;
			this.updateAudio();

		},

		toggleAudio() {

			if ( this.audioElement.paused ) {
				this.audioElement.play();
			} else {
				this.audioElement.pause();
			}

		},

		updateAudio() {

			this.audioListener = new THREE.AudioListener();

			if ( this.audio !== undefined ) {
				this.audio.disconnect();
			}
			this.audio = new THREE.Audio( this.audioListener );
			this.audioAnalyser = new THREE.AudioAnalyser( this.audio, this.soundMapFftLength );
			this.waveAnalyser = new THREE.AudioAnalyser( this.audio, this.fftWaveformLength );

			if ( this.selectedAudioSource === 'File' ) {

				this.audioElement = new Audio( 'sounds/376737_Skullbeatz___Bad_Cat_Maste.mp3' );
				this.audioElement.loop = true;
				this.audio.setMediaElementSource( this.audioElement );
				this.audioElement.play();

			} else {

				navigator.mediaDevices.getUserMedia( { audio: true } ).then( stream => {

					this.audio.setMediaStreamSource( stream );

				} ).catch( err => {

					alert( err );

				} );

			}

		},

		// Sound Map
		updateSoundMap() {

			// Clean previous soundmap
			this.soundMap.geometry.dispose();
			this.soundMap.geometry.deleteAttribute( 'position' );
			this.soundMap.geometry.deleteAttribute( 'color' );
			this.soundMap.geometry.deleteAttribute( 'normal' );
			this.soundMap.material.dispose();

			// Reset cursor
			this.currentAudioBufferIndex = 0;

			// Recreate buffer attributes
			const halfFftLength = this.soundMapFftLength / 2;
			const positions = [];
			const colors = [];
			const indexes = [];

			for ( let x = 0; x < this.soundMapBufferLength; x ++ ) {

				for ( let z = 0; z < halfFftLength; z ++ ) {

					positions.push( x / 100, 0, z / 100 );
					colors.push( 1, 1, 1 );

				}

				// avoid extra indexes
				if ( x === this.soundMapBufferLength - 1 ) {
					break;
				}

				const globalIndex = (x * halfFftLength);
				for ( let i = 0; i < halfFftLength - 1; i ++ ) {

					indexes.push( globalIndex + i, globalIndex + i + 1, globalIndex + i + halfFftLength );
					indexes.push( globalIndex + i + 1, globalIndex + i + halfFftLength + 1, globalIndex + i + halfFftLength );

				}

			}

			const bufferPositionAttribute = new THREE.Float32BufferAttribute( positions, 3 );
			bufferPositionAttribute.setUsage( THREE.DynamicDrawUsage );
			this.soundMap.geometry.setAttribute( 'position', bufferPositionAttribute );

			const bufferColorAttribute = new THREE.Float32BufferAttribute( colors, 3 );
			bufferColorAttribute.setUsage( THREE.DynamicDrawUsage );
			this.soundMap.geometry.setAttribute( 'color', bufferColorAttribute );

			this.soundMap.geometry.setIndex( indexes );
			this.soundMap.geometry.computeVertexNormals();

			// Recentering
			let boundingBoxCenter = new THREE.Vector3();
			this.soundMap.geometry.computeBoundingBox();
			this.soundMap.geometry.boundingBox.getCenter( boundingBoxCenter );
			this.soundMap.position.x = - boundingBoxCenter.x;
			this.soundMap.position.y = - boundingBoxCenter.y;
			this.soundMap.position.z = - boundingBoxCenter.z;

			// Recreate material
			this.soundMap.material = new THREE.MeshPhongMaterial( {
				vertexColors: THREE.VertexColors
			} );

			// Update audioAnalyser
			this.updateAudio();

		},

		// Utils
		getAspectRatio() {

			return (this.container.offsetHeight === 0) ? 1 : this.container.offsetWidth / this.container.offsetHeight;

		},

		resize() {

			let containerWidth = this.container.offsetWidth;
			let containerHeight = this.container.offsetHeight;

			this.renderer.setSize( containerWidth, containerHeight, true );

			this.camera.aspect = this.getAspectRatio();
			this.camera.updateProjectionMatrix();


		},

		// Render
		startRender() {

			if ( this.frameId ) {
				return;
			}

			this.frameId = window.requestAnimationFrame( this.render.bind( this ) );

		},

		render() {

			if ( this.stats && this.showStats ) {
				this.stats.begin();
			}

			this.frameId = window.requestAnimationFrame( this.render.bind( this ) );

			this.renderWaveForm();
			this.renderSoundMap();

			// Render
			this.renderer.render( this.scene, this.camera );

			if ( this.stats && this.showStats ) {
				this.stats.end();
			}

		},

		renderWaveForm() {

			if ( !this.useWaveform ) { return; }

			this.waveAnalyser.analyser.getByteTimeDomainData( this.waveAnalyser.data );
			const waveDatas = this.waveAnalyser.data;

			const waveform = this.waveforms.children[ this.currentWaveformBufferIndex ];
			const positionBufferAttribute = waveform.geometry.getAttribute( 'position' );
			const positionBuffer = positionBufferAttribute.array;
			const colorBufferAttribute = waveform.geometry.getAttribute( 'color' );
			const colorBuffer = colorBufferAttribute.array;

			for ( let i = 0, bi = 0, dataLength = waveDatas.length; i < dataLength; i ++, bi += 3 ) {

				const waveData = waveDatas[ i ];

				//positionBuffer[ bi + 0 ]
				positionBuffer[ bi + 1 ] = (waveData / 255);
				//positionBuffer[ bi + 2 ]

				colorBuffer[ bi + 0 ] = waveData / 255;
				colorBuffer[ bi + 1 ] = (255 - waveData) / 255;
				colorBuffer[ bi + 2 ] = 0;

			}
			positionBufferAttribute.needsUpdate = true;
			colorBufferAttribute.needsUpdate = true;

			this.currentWaveformBufferIndex ++;
			if ( this.currentWaveformBufferIndex >= this.waveformCycles ) {
				this.currentWaveformBufferIndex = 0;
			}

		},

		renderSoundMap() {

			if ( !this.useSoundMap ) { return; }

			const frequencyDatas = this.audioAnalyser.getFrequencyData();

			const currentZIndexOffset = (this.currentAudioBufferIndex * (this.soundMapFftLength / 2));

			const positionBuffer = this.soundMap.geometry.getAttribute( 'position' );
			const colorBuffer = this.soundMap.geometry.getAttribute( 'color' );

			for ( let i = 0, dataLength = frequencyDatas.length; i < dataLength; i ++ ) {
				const fftData = frequencyDatas[ i ];
				const currentIndex = ((currentZIndexOffset + i) * 3);

				positionBuffer.array[ currentIndex + 1 ] = (fftData / 255);

				colorBuffer.array[ currentIndex + 0 ] = fftData / 255;
				colorBuffer.array[ currentIndex + 1 ] = (255 - fftData) / 255;
				colorBuffer.array[ currentIndex + 2 ] = 0;
			}
			positionBuffer.needsUpdate = true;
			colorBuffer.needsUpdate = true;
			this.soundMap.geometry.computeVertexNormals();

			this.currentAudioBufferIndex ++;
			if ( this.currentAudioBufferIndex >= this.soundMapBufferLength ) {
				this.currentAudioBufferIndex = 0;
			}

		},

		stopRender() {

			window.cancelAnimationFrame( this.frameId );
			this.frameId = null;

		}

	} );

	///

	const overlay = document.getElementById( 'overlay' );
	const container = document.getElementById( 'container' );
	const startButton = document.getElementById( 'startButton' );
	const app = new ThreeApplication( container );

	startButton.addEventListener( 'click', () => {

		overlay.remove();
		app.startRender();
		app.setAudioSource( 'File' );

	} );

</script>

</body>
</html>
