"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = {
  lights_fragment_begin: "GeometricContext geometry;geometry.position = - vViewPosition;geometry.normal = normal;geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );#ifdef CLEARCOAT\tgeometry.clearcoatNormal = clearcoatNormal;#endifIncidentLight directLight;#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\tPointLight pointLight;\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\tPointLightShadow pointLightShadow;\t#endif\t#pragma unroll_loop_start\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\t\tpointLight = pointLights[ i ];\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\t\tpointLightShadow = pointLightShadows[ i ];\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\t\t#endif\t\tRE_Direct( directLight, geometry, material, reflectedLight );\t}\t#pragma unroll_loop_end#endif#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\tSpotLight spotLight;\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\tSpotLightShadow spotLightShadow;\t#endif\t#pragma unroll_loop_start\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\t\tspotLight = spotLights[ i ];\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\t\tspotLightShadow = spotLightShadows[ i ];\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\t\t#endif\t\tRE_Direct( directLight, geometry, material, reflectedLight );\t}\t#pragma unroll_loop_end#endif#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\tDirectionalLight directionalLight;\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\tDirectionalLightShadow directionalLightShadow;\t#endif\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\tvec2 cascade;\tfloat cascadeCenter;\tfloat closestEdge;\tfloat margin;\tfloat csmx;\tfloat csmy;\t#pragma unroll_loop_start\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\t\tdirectionalLight = directionalLights[ i ];\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\t\t\t\tcascade = CSM_cascades[ i ];\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\t\tcsmx = cascade.x - margin / 2.0;\t\tcsmy = cascade.y + margin / 2.0;\t\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS && linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\t\t\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS ) {\t\t\t\tvec3 prevColor = directLight.color;\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\t\t\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\t\t\t}\t\t\tReflectedLight prevLight = reflectedLight;\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\t\t}\t}\t#pragma unroll_loop_end\t#else\t#pragma unroll_loop_start\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\t\tdirectionalLight = directionalLights[ i ];\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\t\tdirectionalLightShadow = directionalLightShadows[ i ];\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\t\t#endif\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );\t}\t#pragma unroll_loop_end\t#endif#endif#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\tDirectionalLight directionalLight;\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\tDirectionalLightShadow directionalLightShadow;\t#endif\t#pragma unroll_loop_start\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\t\tdirectionalLight = directionalLights[ i ];\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\t\tdirectionalLightShadow = directionalLightShadows[ i ];\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\t\t#endif\t\tRE_Direct( directLight, geometry, material, reflectedLight );\t}\t#pragma unroll_loop_end#endif#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\tRectAreaLight rectAreaLight;\t#pragma unroll_loop_start\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\t\trectAreaLight = rectAreaLights[ i ];\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\t}\t#pragma unroll_loop_end#endif#if defined( RE_IndirectDiffuse )\tvec3 iblIrradiance = vec3( 0.0 );\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\t#if ( NUM_HEMI_LIGHTS > 0 )\t\t#pragma unroll_loop_start\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\t\t}\t\t#pragma unroll_loop_end\t#endif#endif#if defined( RE_IndirectSpecular )\tvec3 radiance = vec3( 0.0 );\tvec3 clearcoatRadiance = vec3( 0.0 );#endif",
  lights_pars_begin: "#if defined( USE_CSM ) && defined( CSM_CASCADES )uniform vec2 CSM_cascades[CSM_CASCADES];uniform float cameraNear;uniform float shadowFar;#endif\t" + THREE.ShaderChunk.lights_pars_begin
};
exports["default"] = _default;