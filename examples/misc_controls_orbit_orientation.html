<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - orbit controls + orientation helper</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #ccc;
				color: #000;
			}

			a {
				color: #f00;
			}

			.orientation-helper-in-scene {
				position: fixed;
				top: 20px;
				left: 20px;
				width: 100px;
				height: 100px;
				z-index: 10;
			}
		</style>
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - orbit controls + orientation helper
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { GUI } from './jsm/libs/dat.gui.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { OrientationHelper } from './jsm/controls/OrientationHelper.js';

			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { DRACOLoader } from './jsm/loaders/DRACOLoader.js';

			let camera, controls, scene, renderer, orientationHelper, gui;
			let _lastCLick = Date.now();

			const api = { gizmo: 'Default' };
			const models = {};

			init();
			createGUI();

			// This is a static Scene. However, as we're using enableDamping=true the controls "change" event will call the render() function.
			render();
			animate();

			function init() {

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xcccccc );
				scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 400, 200, 0 );

				// extra models for gizmo

				const loader = new GLTFLoader().setPath( 'models/gltf/' );
				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath( 'js/libs/draco/gltf/' );
				loader.setDRACOLoader( dracoLoader );

				loader.load( 'Soldier.glb', function ( gltf ) {
					gltf.scene.scale.set( 50, 50, 50 );
					gltf.scene.position.y = -50;
					models[ 'Soldier' ] = gltf.scene;
					models[ 'Soldier' ].layers.enable( 1 );
				});
				loader.load( 'ferrari.glb', function ( gltf ) {
					gltf.scene.scale.set( 20, 20, 20 );
					gltf.scene.position.y = -20;
					models[ 'Ferrari' ] = gltf.scene;
					models[ 'Ferrari' ].layers.enable( 1 );
				});

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.listenToKeyEvents( window ); // optional

				controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.05;

				controls.screenSpacePanning = false;

				controls.minDistance = 100;
				controls.maxDistance = 500;
				
				// orientation helper
				const ohOptions = {
					className: 'orientation-helper-in-scene'
					}, 
					ohLabels = {
						px: 'East',
						nx: 'West',
						pz: 'South',
						nz: 'North',
						py: 'Sky',
						ny: 'Ground'
					};

				orientationHelper = new OrientationHelper( camera, controls, ohOptions, ohLabels );
				orientationHelper.addEventListener( 'change', onOrientationHelperChange );
				orientationHelper.addEventListener( 'click', onOrientationHelperClick );

				document.body.appendChild(orientationHelper.domElement);

				// world

				const geometry = new THREE.CylinderGeometry( 0, 10, 30, 4, 1 );
				const material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );

				for ( let i = 0; i < 500; i ++ ) {

					const mesh = new THREE.Mesh( geometry, material );
					mesh.position.x = Math.random() * 1600 - 800;
					mesh.position.y = 0;
					mesh.position.z = Math.random() * 1600 - 800;
					mesh.updateMatrix();
					mesh.matrixAutoUpdate = false;
					scene.add( mesh );

				}

				// lights

				const dirLight1 = new THREE.DirectionalLight( 0xffffff );
				dirLight1.position.set( 1, 1, 1 );
				scene.add( dirLight1 );

				const dirLight2 = new THREE.DirectionalLight( 0x002288 );
				dirLight2.position.set( - 1, - 1, - 1 );
				scene.add( dirLight2 );

				const ambientLight = new THREE.AmbientLight( 0x222222 );
				scene.add( ambientLight );

				//

				window.addEventListener( 'resize', onWindowResize );

			}
			
			function onOrientationHelperChange( ev ) {

				translateCamera( ev.direction );

			}

			function onOrientationHelperClick( ev ) {

				// Simulate double-click (less than 250ms)
				let nClick = Date.now();
				if ( nClick - _lastCLick < 250 ) {

					translateCamera( ev.normal );

				}

				_lastCLick = nClick;

			}

			function translateCamera( direction ) {

				controls.enabled = false;

				const dist = camera.position.distanceTo( controls.target ),
					newCameraPos = controls.target.clone().add( direction.multiplyScalar( dist ) );

				camera.position.set(newCameraPos.x, newCameraPos.y, newCameraPos.z);

				controls.enabled = true;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

				//render(); // it's being called by controls onChange event

			}

			function render() {

				renderer.render( scene, camera );

			}

			function createGUI( model, animations ) {

				const gizmos = [ 'Default', 'Soldier', 'Ferrari' ];

				gui = new GUI();

				// states

				const clipCtrl = gui.add( api, 'gizmo' ).options( gizmos );

				clipCtrl.onChange( function () {

					orientationHelper.setGizmo( models[ api.gizmo ], true );

				} );

			}
		</script>

	</body>
</html>
