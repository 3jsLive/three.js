<!--
	@author munrocket / https://twitter.com/munrocket_twit
-->

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js examples</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="./main.css">
		<style> body { background-color: #FFF; } </style>
	</head>

	<body>

		<script src="files.js"></script>

		<script type="module">

			import * as THREE from '../build/three.module.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { SpiralSphereGeometry } from './jsm/geometries/SpiralSphereGeometry.js';

			var camera, scene, renderer, controls;
			var radius, tiles, turns;
			var mouse, mouseDown, mouseTileId;

			init();
			animate();

			function init() {

				// init variables

				radius = 1;
				var gap = 0.03;
				var subgrid = 10;
				var uvCut = 0.02;

				tiles = [];
				for ( var key in files ) {

					var section = files[ key ];
					for ( var i = 0, len = section.length; i < len; i ++ ) {

						tiles.push( section[ i ] );

					}

				}
				turns = Math.PI / Math.sqrt( 4 * Math.PI / tiles.length / 800 * 600 );
				var size = Math.ceil( Math.sqrt( tiles.length ) );

				mouseTileId = null;
				mouse = new THREE.Vector2();
				mouseDown = new THREE.Vector2();

				// camera

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
				camera.position.set( 0, 1.5, 1 );
				camera.matrixWorldNeedsUpdate = true;
				if ( camera.aspect < 1 ) {

					var pos = camera.position.divideScalar( camera.aspect );
					camera.position.set( pos.x, pos.y, pos.z );

				}

				// scene

				var geometry = new SpiralSphereGeometry( radius, turns, gap, gap, subgrid, subgrid, tiles.length );
				for( var tile = 0; tile < geometry.attributes.id.count; tile ++ ) {

					var id = geometry.attributes.id.array[ tile ];
					var i = Math.floor( id / size );

					var u0 = id / size - i + uvCut / size;
					var v0 = 1. - ( i + 1. ) / size + uvCut / size;
					var uh = ( 1 - 2 * uvCut ) / size;
					var vh = ( 1 - 2 * uvCut ) / size;

					geometry.attributes.uv.array[ 2 * tile ] *= uh;
					geometry.attributes.uv.array[ 2 * tile ] += u0;
					geometry.attributes.uv.array[ 2 * tile + 1 ] *= vh;
					geometry.attributes.uv.array[ 2 * tile + 1 ] += v0;

				}

				var material = new THREE.MeshBasicMaterial( { color: 0xAAAAAA } );
				var mesh = new THREE.Mesh( geometry, material );
				new THREE.TextureLoader().load( './screenshots/all_in_one.jpg', function( tex ) {
					material.color = null;
					material.map = tex;
					material.needsUpdate = true;
				});

				scene = new THREE.Scene();
				scene.add( mesh );
				scene.background = new THREE.Color( 0xFFFFFF );

				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );

				controls.enableDamping = true;
				controls.dampingFactor = 0.04;

				controls.screenSpacePanning = false;
				controls.enablePan = false;

				controls.minDistance = 1.05;
				controls.maxDistance = 10;

				window.addEventListener( 'resize', onWindowResize, false );
				window.addEventListener( 'mousedown', onMouseDown, false );
				window.addEventListener( 'mousemove', onMouseMove, false );
				window.addEventListener( 'mouseup', onMouseUp, false );
				window.addEventListener( 'touchstart', onTouchStart, false );
				window.addEventListener( 'touchend', onTouchEnd, false );

			}

			function analyticRaycaster() {

				var ray = new THREE.Ray();
				ray.origin.setFromMatrixPosition( camera.matrixWorld );
				ray.direction.set( mouse.x, mouse.y, 0.5 ).unproject( camera ).sub( ray.origin ).normalize();

				var a = ray.direction.dot( ray.direction );
				var b = 2 * ray.origin.dot( ray.direction );
				var c = ray.origin.dot( ray.origin ) - radius * radius;
				var D = b * b - 4 * a * c;
				if ( D < 0 ) return null;

				var p = new THREE.Vector3();
				var s = ( - b - Math.sqrt( D ) ) / ( 2 * a );
				ray.at( s, p );

				p = new THREE.Spherical().setFromVector3( p );
				p.phi = Math.PI / 2 - p.phi;
				p.theta = ( Math.PI / 2 - p.theta ) % ( 2 * Math.PI );

				var t = p.theta / 2 / turns + Math.PI / turns *
						Math.floor( ( turns * ( Math.PI - 2 * p.phi ) - p.theta ) / ( 2 * Math.PI ) ) - Math.PI / 2;
				return 1 + Math.floor( ( tiles.length - 2 ) * ( Math.cos( Math.PI / 2 / turns ) -
						Math.cos( t + ( turns + 1 ) * Math.PI / 2 / turns ) ) / ( 2 * Math.cos( Math.PI / 2 / turns ) ) );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				renderer.setSize( window.innerWidth, window.innerHeight );
				camera.updateProjectionMatrix();

			}

			function onMouseDown() {

				mouseDown.x = mouse.x;
				mouseDown.y = mouse.y;

			}

			function onMouseMove( e ) {

				mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
				mouseTileId = analyticRaycaster();

			}

			function onMouseUp( e ) {

				onMouseMove( e );
				if ( mouseTileId !== null && mouse.distanceTo( mouseDown ) < 0.03 ) {

					window.location.href = './' + tiles[ mouseTileId ] + '.html';

				}

			}

			function onTouchStart( e ) {

				if ( e.touches.length == 1 ) {

					mouseDown.x = ( e.touches[ 0 ].pageX / window.innerWidth ) * 2 - 1;
					mouseDown.y = - ( e.touches[ 0 ].pageY / window.innerHeight ) * 2 + 1;

				}

			}

			function onTouchEnd( e ) {

				if ( e.changedTouches.length == 1 ) {

					mouse.x = ( e.changedTouches[ 0 ].pageX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( e.changedTouches[ 0 ].pageY / window.innerHeight ) * 2 + 1;
					mouseTileId = analyticRaycaster();

				}

				if ( mouseTileId !== null && mouse.distanceTo( mouseDown ) < 0.15 ) {

					window.location.href = './' + tiles[ mouseTileId ] + '.html';

				}

			}

			function animate() {

				controls.update();
				controls.rotateSpeed = 0.4 * ( camera.position.length() - 0.4 );
				renderer.render( scene, camera );
				requestAnimationFrame( animate );

			}

		</script>

	</body>
</html>
