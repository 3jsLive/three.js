<!--
	@author munrocket / https://twitter.com/munrocket_twit
	Uses modified formulas from paper by Marco Abrate and Fabrizio Pollastri
	Inspired by Callum Prentice page thumbnails
-->

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js examples</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="./main.css">
		<style> body { background-color: #FFF; } </style>
	</head>

	<body>

		<canvas></canvas>

		<script src="files.js"></script>

		<script type="module">

			import * as THREE from '../build/three.module.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { SpiralSphereGeometry } from './jsm/geometries/SpiralSphereGeometry.js';

			var canvas, camera, material, scene, renderer, controls;
			var sphere, radius, turns, examples;
			var mouse, mouseDown, hoverId, zoomSpeed;

			init();
			animate();

			function init() {

				examples = [];
				Object.keys( files ).forEach( key => {
					files[ key ].forEach( name => examples.push( name ) );
				});

				var tileRatio = 800 / 600;
				turns = Math.PI / Math.sqrt( 4 * Math.PI / examples.length / tileRatio );
				radius = 1;
				zoomSpeed = 0.25;
				var gap = 0.03;
				var subGrid = 10;
				var uvZoom = 0.01;
				var uvZoom2 = 0.065;
				var texSize = Math.ceil( Math.sqrt( examples.length ) );

				hoverId = { value : - 1 };
				mouse = new THREE.Vector2();
				mouseDown = new THREE.Vector2();
				canvas = document.getElementsByTagName( 'canvas' )[ 0 ];

				// scene

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xFFFFFF );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
				camera.position.set( 0, 1.5, 1 );
				camera.matrixWorldNeedsUpdate = true;
				if ( camera.aspect < 1 ) {

					var pos = camera.position.divideScalar( camera.aspect );
					camera.position.set( pos.x, pos.y, pos.z );

				}

				sphere = new SpiralSphereGeometry( radius, turns, gap, gap, subGrid, subGrid, examples.length );
				sphere.setAttribute( 'zoom', new THREE.BufferAttribute( new Float32Array( sphere.attributes.id.count ), 1 ) );
				sphere.setAttribute( 'uv2', sphere.attributes.uv.clone() );
				sphere.computeVertexNormals();
				computeTileUVs( sphere, texSize, sphere.attributes.uv, uvZoom );
				computeTileUVs( sphere, texSize, sphere.attributes.uv2, uvZoom2 );

				material = new THREE.MeshBasicMaterial( { color: 0xAAAAAA } );
				material.onBeforeCompile = function ( shader ) {

					shader.vertexShader = [
						'attribute float id;',
						'attribute float zoom;',
						'attribute vec2 uv2;',
						shader.vertexShader
					].join( '\n' );
					shader.vertexShader = shader.vertexShader.replace( '#include <uv_vertex>', [
						'#ifdef USE_UV',
						'  vUv = mix( uv, uv2, zoom );',
						'#endif'
					].join( '\n' ) );

				};
				new THREE.TextureLoader().load( './screenshots/all_in_one.jpg', function( map ) {

					material.color = null;
					material.map = map;
					material.needsUpdate = true;

				} );

				scene.add( new THREE.Mesh( sphere, material ) );

				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true, canvas: canvas } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.dampingFactor = 0.04;
				controls.screenSpacePanning = false;
				controls.enablePan = false;
				controls.minDistance = 1.05;
				controls.maxDistance = 10;

				// events

				window.addEventListener( 'resize', onWindowResize, false );
				window.addEventListener( 'mousedown', onMouseDown, false );
				window.addEventListener( 'mousemove', onMouseMove, false );
				window.addEventListener( 'mouseup', onMouseUp, false );
				window.addEventListener( 'touchstart', onTouchStart, false );
				window.addEventListener( 'touchend', onTouchEnd, false );

			}

			function computeTileUVs( sphere, texSize, aUv, uvZoom ) {

				for ( var i = 0; i < sphere.attributes.id.count; i ++ ) {

					var id = sphere.attributes.id.array[ i ];
					var j = Math.floor( id / texSize );
					var q = ( 1 - 2 * uvZoom ) / texSize;
					var u0 = ( id + uvZoom ) / texSize - j;
					var v0 = 1. - ( j + 1. - uvZoom ) / texSize;

					aUv.array[ 2 * i ] *= q;
					aUv.array[ 2 * i ] += u0;
					aUv.array[ 2 * i + 1 ] *= q;
					aUv.array[ 2 * i + 1 ] += v0;

				}

			}

			function analyticRaycaster() {

				var ray = new THREE.Ray();
				ray.origin.setFromMatrixPosition( camera.matrixWorld );
				ray.direction.set( mouse.x, mouse.y, 0.5 ).unproject( camera ).sub( ray.origin ).normalize();

				var a = ray.direction.dot( ray.direction );
				var b = 2 * ray.origin.dot( ray.direction );
				var c = ray.origin.dot( ray.origin ) - radius * radius;
				var D = b * b - 4 * a * c;
				if ( D < 0 ) return ( - 1 );

				var p = new THREE.Vector3();
				var s = ( - b - Math.sqrt( D ) ) / ( 2 * a );
				ray.at( s, p );

				p = new THREE.Spherical().setFromVector3( p );
				p.phi = Math.PI / 2 - p.phi;
				p.theta = ( Math.PI / 2 - p.theta ) % ( 2 * Math.PI );

				var t = p.theta / 2 / turns + Math.PI / turns *
						Math.floor( ( turns * ( Math.PI - 2 * p.phi ) - p.theta ) / ( 2 * Math.PI ) ) - Math.PI / 2;
				return 1 + Math.floor( ( examples.length - 2 ) * ( Math.cos( Math.PI / 2 / turns ) -
						Math.cos( t + ( turns + 1 ) * Math.PI / 2 / turns ) ) / ( 2 * Math.cos( Math.PI / 2 / turns ) ) );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				renderer.setSize( window.innerWidth, window.innerHeight );
				camera.updateProjectionMatrix();

			}

			function onMouseDown() {

				mouseDown.x = mouse.x;
				mouseDown.y = mouse.y;

			}

			function onMouseMove( e ) {

				mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
				hoverId.value = analyticRaycaster();
				canvas.style.cursor = ( hoverId.value >= 0 ) ? 'auto' : 'pointer';

			}

			function onMouseUp( e ) {

				onMouseMove( e );
				if ( hoverId.value >= 0 && mouse.distanceTo( mouseDown ) < 0.03 ) {

					window.location.href = './' + examples[ hoverId.value ] + '.html';

				}

			}

			function onTouchStart( e ) {

				if ( e.touches.length == 1 ) {

					mouseDown.x = ( e.touches[ 0 ].pageX / window.innerWidth ) * 2 - 1;
					mouseDown.y = - ( e.touches[ 0 ].pageY / window.innerHeight ) * 2 + 1;

				}

			}

			function onTouchEnd( e ) {

				if ( e.changedTouches.length == 1 ) {

					mouse.x = ( e.changedTouches[ 0 ].pageX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( e.changedTouches[ 0 ].pageY / window.innerHeight ) * 2 + 1;
					hoverId.value = analyticRaycaster();

				}

				if ( hoverId.value >= 0 && mouse.distanceTo( mouseDown ) < 0.15 ) {

					window.location.href = './' + examples[ hoverId.value ] + '.html';

				}

			}

			function animate( now ) {

				for ( var i = 0, attr = sphere.attributes; i < attr.id.count; i ++ ) {

					var dz = ( attr.id.array[ i ] === hoverId.value ) ? zoomSpeed : - zoomSpeed;
					attr.zoom.array[ i ] = Math.max( 0, Math.min( 1, attr.zoom.array[ i ] + dz ) );
					attr.zoom.needsUpdate = true;

				}
				controls.update();
				controls.rotateSpeed = 0.4 * ( camera.position.length() - 0.4 );

				renderer.render( scene, camera );
				requestAnimationFrame( animate );

			}

		</script>

	</body>
</html>
