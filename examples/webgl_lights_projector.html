<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - lights - projector</title>
	<meta charset="utf-8">
	<meta name="viewport"
				content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			background-color: #000;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			color: #ffffff;
			padding: 5px;
			font-family: Monospace;
			font-size: 13px;
			text-align: center;
		}

		a {
			color: #ff0080;
			text-decoration: none;
		}

		a:hover {
			color: #0080ff;
		}
	</style>
</head>
<body>

<div id="info">
	<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webgl
	- projector by <a href="http://github.com/usefulthink" target="_blank"
												 rel="noopener">Martin Schuhfuss</a><br/>
</div>

<video id="video" autoplay loop webkit-playsinline muted style="display: none;">
	<source src="textures/sintel.mp4"
					type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
	<source src="textures/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>
</video>

<script src="../build/three.js"></script>
<script src="js/controls/OrbitControls.js"></script>

<script src="js/libs/dat.gui.min.js"></script>

<script src="js/Detector.js"></script>

<script>

	if ( !Detector.webgl ) Detector.addGetWebGLMessage();

	var renderer, scene, camera;
	var controls;
	var projector;
	var shadowCameraHelper;
	var helpers = [];

	var gui;

	var textures = {};

	function initTextures() {

		var textureLoader = new THREE.TextureLoader();
		var texture;

		texture = textureLoader.load( 'textures/UV_Grid_Sm.jpg' );

		textures.uvGrid = texture;

		var video = document.getElementById( 'video' );
		texture = new THREE.VideoTexture( video );
		texture.minFilter = THREE.LinearFilter;
		texture.magFilter = THREE.LinearFilter;
		texture.format = THREE.RGBFormat;

		textures.video = texture;

	}

	function init() {

		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;

		renderer.gammaInput = true;
		renderer.gammaOutput = true;

		scene = new THREE.Scene();

		camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 );
		camera.position.set( 65, 8, -10 );

		controls = new THREE.OrbitControls( camera, renderer.domElement );
		controls.minDistance = 20;
		controls.maxDistance = 500;
		controls.enablePan = false;

		var ambient = new THREE.AmbientLight( 0xffffff, 0.1 );
		scene.add( ambient );

		projector = new THREE.Projector( 0xffffff, 1 );

		projector.map = textures.uvGrid;
		projector.position.set( 15, 40, 35 );
		projector.angle = Math.PI / 3;
		projector.fov = 60;
		projector.aspect = 1;
		projector.decay = 2;
		projector.distance = 200;

		projector.castShadow = true;
		projector.shadow.mapSize.width = 1024;
		projector.shadow.mapSize.height = 1024;
		projector.shadow.camera.near = 10;
		projector.shadow.camera.far = 200;

		scene.add( projector );

		shadowCameraHelper = new THREE.CameraHelper( projector.shadow.camera );

		helpers.push( shadowCameraHelper );
		helpers.push( new THREE.AxesHelper( 10 ) );
		helpers.push( new THREE.GridHelper( 100, 10 ) );

		scene.add.apply( scene, helpers );

		var floor = new THREE.Mesh(
				new THREE.BoxGeometry( 2000, 1, 2000 ),
				new THREE.MeshPhongMaterial( { color: 0x808080, dithering: true } )
		);
		floor.position.set( 0, -1, 0 );
		floor.receiveShadow = true;
		scene.add( floor );

		var box1 = new THREE.Mesh(
				new THREE.BoxGeometry( 3, 1, 2 ),
				new THREE.MeshPhongMaterial( { color: 0xffffff, dithering: true } )
		);
		box1.position.set( -10, 2, 0 );
		box1.castShadow = true;
		scene.add( box1 );

		var box2 = new THREE.Mesh(
				new THREE.BoxGeometry( 3, 10, 2 ),
				new THREE.MeshPhongMaterial( { color: 0xffffff, dithering: true } )
		);
		box2.position.set( 20, 4, 0 );
		box2.castShadow = true;
		scene.add( box2 );

		projector.target = box2;

		controls.target.copy( box2.position );
		controls.update();

		window.addEventListener( 'resize', onResize, false );

	}

	function onResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function buildGui() {

		gui = new dat.GUI();

		var params = {
			'light color': projector.color.getHex(),
			intensity: projector.intensity,
			distance: projector.distance,
			fov: projector.fov,
			aspect: projector.aspect,
			decay: projector.decay,
			rotation: projector.rotation.z,
			texture: 'uvGrid',
			showHelpers: true
		};

		gui.addColor( params, 'light color' ).onChange( function ( val ) {
			projector.color.setHex( val );
		} );
		gui.add( params, 'intensity', 0, 2 ).onChange( function ( val ) {
			projector.intensity = val;
		} );
		gui.add( params, 'distance', 50, 200 ).onChange( function ( val ) {
			projector.distance = val;
		} );
		gui.add( params, 'decay', 1, 2 ).onChange( function ( val ) {
			projector.decay = val;
		} );
		gui.add( params, 'fov', 10, 120 ).onChange( function ( val ) {
			projector.fov = val;
		} );
		gui.add( params, 'aspect', 0.5, 2 ).onChange( function ( val ) {
			projector.aspect = val;
		} );
		gui.add( params, 'texture', Object.keys( textures ) ).onChange( function ( val ) {
			projector.map = textures[ val ];
		} );
		gui.add( params, 'rotation', -Math.PI, Math.PI ).onChange( function ( val ) {
			projector.rotation.z = val;
		} );
		gui.add( params, 'showHelpers' ).onChange( function ( val ) {
			helpers.forEach( function ( helper ) { helper.visible = val; } );
		} );
		gui.open();

	}

	initTextures();
	init();

	buildGui();

	requestAnimationFrame( function __loop() {
		controls.update();
		renderer.render( scene, camera );
		shadowCameraHelper.update();
		requestAnimationFrame( __loop );
	} );

</script>

</body>

</html>
