<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - postprocessing - Screen Space Ambient Occlusion</title>
	<meta charset="utf-8">
	<meta name="viewport"
				content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css"
				rel="stylesheet"
				href="main.css">
	<style>
		body {
			/* background-color: #aaa; */
		}
	</style>
</head>

<body>
	<div id="info">
		<a href="https://threejs.org"
			 target="_blank"
			 rel="noopener">three.js</a> - screen space ambient occlusion<br />
	</div>

	<script type="module">

		import * as THREE from '../build/three.module.js';

		import Stats from './jsm/libs/stats.module.js';
		import { GUI } from './jsm/libs/dat.gui.module.js';

		import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
		import { SSRPass } from './jsm/postprocessing/SSRPass.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js'

		var container, stats;
		var camera, scene, renderer;
		var composer;
		var group;
		var s = {}

		init();
		animate();

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			renderer = new THREE.WebGLRenderer();
			s.renderer = renderer
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);


			if (1) {

				s.cameraNear = 1
				s.cameraFar = 11
				s.cameraZ = 6
				s.cameraRadius = 2
				// s.camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, s.cameraNear, s.cameraFar)
				camera = new THREE.OrthographicCamera(-s.cameraRadius, s.cameraRadius, s.cameraRadius, -s.cameraRadius, s.cameraNear, s.cameraFar)
				s.camera = camera
				s.camera.position.z = s.cameraZ

				scene = new THREE.Scene();
				s.scene = scene
				// scene.background = new THREE.Color(0xaaaaaa);
				{//mesh
					let geo = new THREE.BoxBufferGeometry(1, 1, 1)
					// let geo = new THREE.IcosahedronBufferGeometry(.5, 3)
					let mtl = new THREE.MeshBasicMaterial({
						color: 'red',
						side: THREE.DoubleSide,
					})
					let mesh = new THREE.Mesh(geo, mtl)
					s.mesh = mesh
					s.scene.add(mesh)
					window.mesh = mesh
					// mesh.position.x=2
					// mesh.position.y=1
				}
				// {//mesh 2
				//   let geo = new THREE.BoxBufferGeometry(1, 1, 1)
				//   // let geo = new THREE.IcosahedronBufferGeometry(.5, 2)
				//   let mesh = new THREE.Mesh(geo, s.mtl_depth)
				//   s.mesh_2 = mesh
				//   // s.scene.add(mesh)
				//   window.mesh = mesh
				//   mesh.position.x = 2
				// }
				{//ground
					let geo = new THREE.PlaneBufferGeometry(4, 4)
					let mtl = new THREE.MeshBasicMaterial({
						color: 'blue',
						side: THREE.DoubleSide,
					})
					let mesh = new THREE.Mesh(geo, mtl)
					s.ground = mesh
					s.scene.add(mesh)
					// mesh.rotation.x = -Math.PI / 2
					// mesh.position.y = -.5
					geo.rotateX(-Math.PI / 2)
					geo.translate(0, -.5, 0)
				}
			}

			if (0) {

				s.cameraNear = 100
				s.cameraFar = 700
				s.cameraZ = 500
				s.cameraRadius = 300
				// s.camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, s.cameraNear, s.cameraFar)
				camera = new THREE.OrthographicCamera(-s.cameraRadius, s.cameraRadius, s.cameraRadius, -s.cameraRadius, s.cameraNear, s.cameraFar)
				s.camera = camera
				s.camera.position.z = s.cameraZ

				scene = new THREE.Scene();
				s.scene = scene
				// scene.background = new THREE.Color(0xaaaaaa);

				scene.add(new THREE.DirectionalLight());
				scene.add(new THREE.HemisphereLight());

				group = new THREE.Group();
				scene.add(group);

				var geometry = new THREE.BoxBufferGeometry(10, 10, 10);

				for (var i = 0; i < 100; i++) {

					var material = new THREE.MeshLambertMaterial({
						color: Math.random() * 0xffffff
					});

					var mesh = new THREE.Mesh(geometry, material);
					mesh.position.x = Math.random() * 400 - 200;
					mesh.position.y = Math.random() * 400 - 200;
					mesh.position.z = Math.random() * 400 - 200;
					mesh.rotation.x = Math.random();
					mesh.rotation.y = Math.random();
					mesh.rotation.z = Math.random();

					mesh.scale.setScalar(Math.random() * 10 + 2);
					group.add(mesh);

				}
			}

			new OrbitControls(s.camera, s.renderer.domElement)

			stats = new Stats();
			container.appendChild(stats.dom);

			var width = window.innerWidth;
			var height = window.innerHeight;

			composer = new EffectComposer(renderer);

			var ssrPass = new SSRPass(scene, camera, width, height, s.cameraRadius, s.cameraNear, s.cameraFar);
			ssrPass.kernelRadius = 16;
			composer.addPass(ssrPass);

			// Init gui
			var gui = new GUI();

			// console.log(ssrPass)
			gui.add(ssrPass, 'output', {
				'Default': SSRPass.OUTPUT.Default,
				'SSR Only': SSRPass.OUTPUT.SSR,
				'SSR Only + Blur': SSRPass.OUTPUT.Blur,
				'Beauty': SSRPass.OUTPUT.Beauty,
				'Depth': SSRPass.OUTPUT.Depth,
				'Normal': SSRPass.OUTPUT.Normal
			}).onChange(function (value) {

				ssrPass.output = parseInt(value);

			});
			gui.add(ssrPass, 'kernelRadius').min(0).max(32);
			gui.add(ssrPass, 'minDistance').min(0.001).max(0.02);
			gui.add(ssrPass, 'maxDistance').min(0.01).max(0.3);

			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {

			var width = window.innerWidth;
			var height = window.innerHeight;

			camera.aspect = width / height;
			camera.updateProjectionMatrix();

			renderer.setSize(width, height);
			composer.setSize(width, height);

		}

		function animate() {

			requestAnimationFrame(animate);

			stats.begin();
			render();
			stats.end();

		}

		function render() {

			var timer = performance.now();
			if (0) {
				group.rotation.x = timer * 0.0002;
				group.rotation.y = timer * 0.0001;
			}

			composer.render();

		}

	</script>
</body>

</html>
