<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<base href="../../../" />
		<script src="list.js"></script>
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>[name]</h1>

		<p>이 섹션의 목적은 three.js를에 대한 간략한 소개를 제공하는 것입니다. 먼저, 회전하는 큐브의 장면을 설정하는 것으로 시작해봅시다. 뭐가뭔지 모르겠다면 페이지 하단에 있는 정상적으로 작동하는 예제로 도움을 받을 수 있습니다.</p>

		<h2>시작하기 전에</h2>

		<p>three.js를 시작하기 전에 예제를 표시할 곳이 필요합니다. 아래 HTML을 js/ 폴더 안 [link:https://threejs.org/build/three.js three.js]의 복사본과 함께 컴퓨터의 파일로 저장하시고 브라우저에서 열어주세요.</p>

		<code>
		&lt;!DOCTYPE html&gt;
		&lt;html&gt;
			&lt;head&gt;
				&lt;meta charset="utf-8"&gt;
				&lt;title&gt;나의 첫 THREE.JS 앱&lt;/title&gt;
				&lt;style&gt;
					body { margin: 0; }
					canvas { display: block; }
				&lt;/style&gt;
			&lt;/head&gt;
			&lt;body&gt;
				&lt;script src="js/three.js"&gt;&lt;/script&gt;
				&lt;script&gt;
					// 자바스크립트 코드는 여기에 추가됩니다.
				&lt;/script&gt;
			&lt;/body&gt;
		&lt;/html&gt;
		</code>

		<p>준비는 끝났습니다. 이제 아래 모든 코드들은 비어있는 &lt;script&gt; 태그안으로 들어갑니다.</p>

		<h2>장면 생성하기</h2>

		<p>three.js와 함께 무언가를 표시하고 장면을 카메라와 함께 랜더링하기 위해 장면, 카메라, 랜더러 총 3가지가 필요합니다.</p>

		<code>
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

		var renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );
		</code>

		<p>여기서 무슨 일이 일어나고 있는지 잠시 설명해봅시다. 우리는 이제 장면, 카메라, 렌더러를 설정했습니다.</p>

		<p>three.js 카메라들에는 몇가지 차이점이 있습니다. 지금은 <strong>PerspectiveCamera</strong>를 사용해봅시다.</p>

		<p>첫 번째 속성은 시야입니다. <strong>시야</strong>는 주어진 순간에 디스플레이에서 볼 수 있는 장면의 범위입니다 이 값은 각도입니다.</p>

		<p>두 번째는 <strong>종횡비(가로 세로의 비율)</strong>입니다. 거의 높이로 나눠진 엘리먼트의 너비를 사용하겠지만, 그렇지 않다면 와이드 스크린에서 오래된 영화를 볼 때와 비슷한 느낌이 나타납니다. (이미지가 찌그러진 것처럼 보입니다)</p>

		<p>The next two attributes are the <strong>near</strong> and <strong>far</strong> clipping plane. What that means, is that objects further away from the camera than the value of <strong>far</strong> or closer than <strong>near</strong> won't be rendered. You don't have to worry about this now, but you may want to use other values in your apps to get better performance.</p>

		<p>Next up is the renderer. This is where the magic happens. In addition to the WebGLRenderer we use here, three.js comes with a few others, often used as fallbacks for users with older browsers or for those who don't have WebGL support for some reason.</p>

		<p>In addition to creating the renderer instance, we also need to set the size at which we want it to render our app. It's a good idea to use the width and height of the area we want to fill with our app - in this case, the width and height of the browser window. For performance intensive apps, you can also give <strong>setSize</strong> smaller values, like <strong>window.innerWidth/2</strong> and <strong>window.innerHeight/2</strong>, which will make the app render at half size.</p>

		<p>If you wish to keep the size of your app but render it at a lower resolution, you can do so by calling <strong>setSize</strong> with false as <strong>updateStyle</strong> (the third argument). For example, <strong>setSize(window.innerWidth/2, window.innerHeight/2, false)</strong> will render your app at half resolution, given that your &lt;canvas&gt; has 100% width and height.</p>

		<p>Last but not least, we add the <strong>renderer</strong> element to our HTML document. This is a &lt;canvas&gt; element the renderer uses to display the scene to us.</p>

		<p><em>"That's all good, but where's that cube you promised?"</em> Let's add it now.</p>

		<code>
		var geometry = new THREE.BoxGeometry();
		var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
		var cube = new THREE.Mesh( geometry, material );
		scene.add( cube );

		camera.position.z = 5;
		</code>

		<p>To create a cube, we need a <strong>BoxGeometry</strong>. This is an object that contains all the points (<strong>vertices</strong>) and fill (<strong>faces</strong>) of the cube. We'll explore this more in the future.</p>

		<p>In addition to the geometry, we need a material to color it. Three.js comes with several materials, but we'll stick to the <strong>MeshBasicMaterial</strong> for now. All materials take an object of properties which will be applied to them. To keep things very simple, we only supply a color attribute of <strong>0x00ff00</strong>, which is green. This works the same way that colors work in CSS or Photoshop (<strong>hex colors</strong>).</p>

		<p>The third thing we need is a <strong>Mesh</strong>. A mesh is an object that takes a geometry, and applies a material to it, which we then can insert to our scene, and move freely around.</p>

		<p>By default, when we call <strong>scene.add()</strong>, the thing we add will be added to the coordinates <strong>(0,0,0)</strong>. This would cause both the camera and the cube to be inside each other. To avoid this, we simply move the camera out a bit.</p>

		<h2>Rendering the scene</h2>

		<p>If you copied the code from above into the HTML file we created earlier, you wouldn't be able to see anything. This is because we're not actually rendering anything yet. For that, we need what's called a <strong>render or animate loop</strong>.</p>

		<code>
		function animate() {
			requestAnimationFrame( animate );
			renderer.render( scene, camera );
		}
		animate();
		</code>

		<p>This will create a loop that causes the renderer to draw the scene every time the screen is refreshed (on a typical screen this means 60 times per second). If you're new to writing games in the browser, you might say <em>"why don't we just create a setInterval ?"</em> The thing is - we could, but <strong>requestAnimationFrame</strong> has a number of advantages. Perhaps the most important one is that it pauses when the user navigates to another browser tab, hence not wasting their precious processing power and battery life.</p>

		<h2>Animating the cube</h2>

		<p>If you insert all the code above into the file you created before we began, you should see a green box. Let's make it all a little more interesting by rotating it.</p>

		<p>Add the following right above the <strong>renderer.render</strong> call in your <strong>animate</strong> function:</p>

		<code>
		cube.rotation.x += 0.01;
		cube.rotation.y += 0.01;
		</code>

		<p>This will be run every frame (normally 60 times per second), and give the cube a nice rotation animation. Basically, anything you want to move or change while the app is running has to go through the animate loop. You can of course call other functions from there, so that you don't end up with a <strong>animate</strong> function that's hundreds of lines.</p>

		<h2>The result</h2>
		<p>Congratulations! You have now completed your first three.js application. It's simple, you have to start somewhere.</p>

		<p>The full code is available below and as an editable [link:https://jsfiddle.net/mkba0ecu/ live example]. Play around with it to get a better understanding of how it works.</p>

		<code>
		&lt;html&gt;
			&lt;head&gt;
				&lt;title&gt;My first three.js app&lt;/title&gt;
				&lt;style&gt;
					body { margin: 0; }
					canvas { display: block; }
				&lt;/style&gt;
			&lt;/head&gt;
			&lt;body&gt;
				&lt;script src="js/three.js"&gt;&lt;/script&gt;
				&lt;script&gt;
					var scene = new THREE.Scene();
					var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

					var renderer = new THREE.WebGLRenderer();
					renderer.setSize( window.innerWidth, window.innerHeight );
					document.body.appendChild( renderer.domElement );

					var geometry = new THREE.BoxGeometry();
					var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
					var cube = new THREE.Mesh( geometry, material );
					scene.add( cube );

					camera.position.z = 5;

					var animate = function () {
						requestAnimationFrame( animate );

						cube.rotation.x += 0.01;
						cube.rotation.y += 0.01;

						renderer.render( scene, camera );
					};

					animate();
				&lt;/script&gt;
			&lt;/body&gt;
		&lt;/html&gt;
		</code>
	</body>
</html>
