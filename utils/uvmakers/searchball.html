<!DOCTYPE html>
<!--
	@author munrocket / https://twitter.com/munrocket_twit
-->
<html lang="en">
<head>
	<title>Screenshot tile mapping</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="icon" href="data:;base64,iVBORw0KGgo=">
	<link type="text/css" rel="stylesheet" href="../../examples/main.css">
	<style> body { background-color: #FFF; } </style>
</head>
<body>

	<div id="container"></div>

	<script id="vertexShader" type="x-shader/x-vertex">
		uniform float uSize;

		varying vec2 vUv;

		void main()  {

			vUv = uv.xy;
			gl_Position = vec4( position, 1.0 );

		}
	</script>

	<script id="fragmentShader" type="x-shader/x-fragment">
		varying vec2 vUv;

		uniform float uId;
		uniform float uSize;
		uniform sampler2D uTile;

		void main()  {

			vec2 uv = fract( vUv * uSize );

			float u0 = fract( uId / uSize );
			float u1 = u0 + 1. / uSize;
			float v0 = 1. - ( floor( uId / uSize ) + 1. ) / uSize;
			float v1 = v0 + 1. / uSize;

			if ( u0 < vUv.x && vUv.x < u1 && v0 < vUv.y && vUv.y < v1 ) {

				gl_FragColor = texture2D( uTile, uv);

			} else {

				discard;

			}

		}
	</script>

	<script src="../../examples/files.js"></script>

	<script type="module">

		import * as THREE from '../../build/three.module.js';

		const resolution = 4096;

		let container, camera, scene, target, geometry, material, mesh, screenshots;
		let renderer, _scene, _mesh, _material;

		let tiles = 0;
		let id = 0;
		for ( var key in files ) {

			tiles += files[ key ].length;

		}
		const size = Math.ceil( Math.sqrt( tiles ) );
		window.chromeRenderFinished = false;

		init();

		function init() {

			screenshots = [];

			for ( var key in files ) {

				var section = files[ key ];
				for (var i = 0; i < section.length; i ++ ) {

					var file = '../../examples/screenshots/' + section[ i ] + '.png';
					screenshots.push( new Promise( resolve => new THREE.TextureLoader().load( file, resolve ) ) );

				}

			}

			Promise.all( screenshots ).then( result => {

				screenshots = result;

				geometry = new THREE.PlaneBufferGeometry( 2, 2 );
				material = new THREE.ShaderMaterial( {
					uniforms: {
						'uTile': { value: screenshots[ 0 ] },
						'uId': { value: 0 },
						'uSize': { value: size }
					},
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent
				} );
				material.blending = THREE.CustomBlending;
				mesh = new THREE.Mesh( geometry, material );

				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
				scene = new THREE.Scene();
				scene.add( mesh );
				target = new THREE.WebGLRenderTarget( resolution, resolution, { depthBuffer: false, stencilBuffer: false } );

				_material = new THREE.MeshBasicMaterial( { map: target.texture } );
				_mesh = new THREE.Mesh( geometry, _material );
				_scene = new THREE.Scene();
				_scene.add( _mesh );

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( resolution, resolution );
				renderer.autoClearColor = false;
				renderer.preserveDrawingBuffer = true;

				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				requestAnimationFrame( render );

			} )

		}

		function render() {

			if ( id < tiles ) {

				for ( let i = 0; i < 40; i++ ) {

					renderer.setRenderTarget( target );
					material.uniforms.uId.value = id;
					material.uniforms.uTile.value = screenshots[ id ];
					renderer.render( scene, camera );
					id ++;

				}

			} else {

				window.chromeRenderFinished = true;

			}

			renderer.setRenderTarget( null );
			renderer.render( _scene, camera );

			requestAnimationFrame( render );

		}

	</script>

</body>
</html>
