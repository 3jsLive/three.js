<!DOCTYPE html>
<html lang="en">
<head>
	<title>Octahedron sphere mapping</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="icon" href="data:;base64,iVBORw0KGgo=">
	<link type="text/css" rel="stylesheet" href="../../examples/main.css">
	<style> body { background-color: #FFF; } </style>
</head>
<body>

	<div id="container"></div>

	<script id="vertexShader" type="x-shader/x-vertex">
		attribute vec2 tile_uv;
		attribute float tile_id;
		varying vec2 vUv;
		varying float vId;

		void main()	{

			vUv = tile_uv;
			vId = tile_id;
			gl_Position = vec4( uv * 2.0 - 1.0, 0.0, 1.0 );

		}
	</script>

	<script id="fragmentShader" type="x-shader/x-fragment">
		varying vec2 vUv;
		varying float vId;
		uniform sampler2D screenshot;
		uniform float uId;

		void main()	{

			if ( abs( vId - uId ) < 0.3 ) {
				gl_FragColor = texture2D( screenshot, vUv );
			} else {
				gl_FragColor = vec4( 0. );
			}

		}
	</script>

	<script src="../../examples/files.js"></script>

	<script type="module">

		import * as THREE from '../../build/three.module.js';
		import { SpiralSphereGeometry } from '../../examples/jsm/geometries/SpiralSphereGeometry.js';

		let container, camera, scene, target, geometry, material, mesh, screenshots;
		let renderer, _scene, _mesh, _material;

		window.chromeRenderFinished = false;
		let tiles = 365;
		const turns = 20;
		const tilesQuads = 100;
		const gap = 0;
		const size = 2048;

		init();

		function computeTilesAttributes( tiles, tilesQuads, count ) {

			let tile_uv = [];
			let tile_id = [];

			for ( let i = 0; i <= tiles * tilesQuads; i ++ ) {

				let tileId = Math.floor( i / tilesQuads ) + 1;
				let vertId = Math.floor( i % tilesQuads );
				let x = vertId / tilesQuads;
				tile_uv.push( x, 1 );
				tile_uv.push( x, 0 );
				tile_id.push( tileId, tileId );

			}

			for ( let i = tiles * tilesQuads + 1; i < count; i += 2 ) {

				let x = i / tilesQuads;
				tile_uv.push( 0, 0 );
				tile_uv.push( 0, 1 );
				tile_id.push( 0, 0 );

			}

			return {
				tile_uv: new THREE.Float32BufferAttribute( tile_uv, 2 ),
				tile_id: new THREE.Float32BufferAttribute( tile_id, 1 )
			};

		}

		function init() {

			screenshots = [];
			for (var key in files) {
				var section = files[key];
				for (var i = 0; i < section.length; i++) {
					screenshots.push(
						new Promise(
							resolve => new THREE.TextureLoader()
								.load( '../../examples/screenshots/' + section[ i ] + '.png', resolve )
						)
					);
				}
			}

			Promise.all( screenshots ).then( result => {

				screenshots = result;
				geometry = new SpiralSphereGeometry( 1, turns, tiles, tilesQuads, gap );
				var attributes = computeTilesAttributes( tiles, tilesQuads, geometry.attributes.uv.count );
				geometry.setAttribute( 'tile_uv', attributes.tile_uv );
				geometry.setAttribute( 'tile_id', attributes.tile_id );
				material = new THREE.ShaderMaterial( {
					uniforms: {
						'screenshot': { value: screenshots[ 0 ] },
						'uId': { value: 0 }
					},
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent
				} );
				material.blending = THREE.CustomBlending;
				material.alphaTest = 0.1;
				material.needsUpdate = true;
				mesh = new THREE.Mesh( geometry, material );

				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
				scene = new THREE.Scene();
				scene.add( mesh );
				target = new THREE.WebGLRenderTarget( size, size, { depthBuffer: false, stencilBuffer: false } );

				_material = new THREE.MeshBasicMaterial( { map: target.texture } );
				_mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), _material );
				_scene = new THREE.Scene();
				_scene.add( _mesh );

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( size, size );
				renderer.autoClearColor = false;
				renderer.preserveDrawingBuffer = true;

				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				render();

			})

		}

		function render() {

			for (let id = 0; id < tiles; id ++ ) {
				renderer.setRenderTarget( target );
				material.uniforms.uId.value = id + 1;
				material.uniforms.screenshot.value = screenshots[ id ];
				renderer.render( scene, camera );
			}

			renderer.setRenderTarget( null );
			renderer.render( _scene, camera );
			window.chromeRenderFinished = true;

		}

	</script>

</body>
</html>
